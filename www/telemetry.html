<!DOCTYPE HTML>
<!--
	Landed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>ConduitNet Telemetry - Distributed Tracing & Observability</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="Learn how ConduitNet implements distributed tracing using System.Diagnostics.Activity and W3C Trace Context across WebSocket transports." />
		<meta name="keywords" content="ConduitNet, Telemetry, OpenTelemetry, Distributed Tracing, .NET 9, System.Diagnostics.Activity, W3C Trace Context" />

		<!-- Open Graph / Facebook -->
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://conduitnet.com/telemetry.html" />
		<meta property="og:title" content="ConduitNet Telemetry & Observability" />
		<meta property="og:description" content="End-to-end visibility into your distributed fabric with zero external dependencies in the core." />
		<meta property="og:image" content="https://conduitnet.com/images/conduit.png" />

		<!-- Twitter -->
		<meta property="twitter:card" content="summary_large_image" />
		<meta property="twitter:url" content="https://conduitnet.com/telemetry.html" />
		<meta property="twitter:title" content="ConduitNet Telemetry & Observability" />
		<meta property="twitter:description" content="End-to-end visibility into your distributed fabric with zero external dependencies in the core." />
		<meta property="twitter:image" content="https://conduitnet.com/images/conduit.png" />

		<script type="module" src="/src/telemetry.ts"></script>
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<header id="header">
					<h1 id="logo"><a href="index.html">ConduitNet</a></h1>
					<nav id="nav">
						<ul>
							<li><a href="index.html">Home</a></li>
							<li><a href="blog.html">Architecture</a></li>
							<li><a href="telemetry.html">Telemetry</a></li>
							<li><a href="stats.html">Stats</a></li>
						</ul>
					</nav>
				</header>

			<!-- Hero -->
                <conduit-hero 
                    background-image="images/background10.png"
                    title="Distributed Observability" 
                    subtitle="Tracing requests across the wire with System.Diagnostics.Activity"
                ></conduit-hero>

			<!-- Main Content -->
				<div id="main" class="wrapper style1">
					<div class="container">
						<header class="major">
							<h2>The Black Box Problem</h2>
							<p>In distributed systems, knowing <em>that</em> a request failed is easy. Knowing <em>where</em> and <em>why</em> is hard.</p>
						</header>

						<!-- Content -->
							<section>
								<h3>Native Tracing Support</h3>
								<p>ConduitNet 0.2 introduces native support for distributed tracing without taking a hard dependency on OpenTelemetry libraries in the core. Instead, we leverage the powerful <code>System.Diagnostics.Activity</code> API built into .NET.</p>
								<p>This allows ConduitNet to be lightweight while still being fully compatible with the OpenTelemetry ecosystem (Jaeger, Zipkin, Prometheus, etc.).</p>

                                <hr />

                                <h3>How It Works</h3>
                                <p>The telemetry pipeline is built directly into the <code>ConduitPipelineExecutor</code> (Client) and <code>ConduitMessageProcessor</code> (Server).</p>

                                <h4>1. The Activity Source</h4>
                                <p>We define a central <code>ActivitySource</code> named <strong>"ConduitNet"</strong>. All traces generated by the framework originate from this source.</p>
                                <pre><code>internal static class ConduitTelemetry
{
    public static readonly ActivitySource ActivitySource = new("ConduitNet", "1.0.0");
}</code></pre>

                                <h4>2. W3C Trace Context Propagation</h4>
                                <p>Since ConduitNet uses a custom WebSocket transport, we manually propagate the W3C Trace Context headers (<code>traceparent</code> and <code>tracestate</code>). This ensures that a trace started on the Client continues seamlessly on the Server.</p>
                                
                                <div class="row">
                                    <div class="col-6 col-12-medium">
                                        <h4>Client Side</h4>
                                        <p>Before sending a message, the client starts an Activity and injects the current context into the message headers.</p>
                                        <pre><code>// ConduitPipelineExecutor.cs
using var activity = ConduitTelemetry.ActivitySource.StartActivity(
    "ConduitClient.Execute", 
    ActivityKind.Client
);

// Inject W3C headers
if (activity != null)
{
    message.Headers["traceparent"] = activity.Id;
    if (activity.TraceStateString != null)
    {
        message.Headers["tracestate"] = activity.TraceStateString;
    }
}</code></pre>
                                    </div>
                                    <div class="col-6 col-12-medium">
                                        <h4>Server Side</h4>
                                        <p>The server extracts these headers and starts a linked Activity, preserving the distributed trace.</p>
                                        <pre><code>// ConduitMessageProcessor.cs
// Extract parent context
if (message.Headers.TryGetValue("traceparent", out var traceParent))
{
    // Start activity with parent context
    using var activity = ConduitTelemetry.ActivitySource.StartActivity(
        "ConduitServer.Process",
        ActivityKind.Server,
        traceParent
    );
    // ... process message
}</code></pre>
                                    </div>
                                </div>

                                <hr />

                                <h3>Visualizing the Data</h3>
                                <p>Because we use standard .NET APIs, you can visualize traces using any OpenTelemetry-compatible tool. Here is an example of a trace visualized in the console, showing the flow from Client to Gateway to Leader Node.</p>

                                <div class="box">
                                    <pre><code>Activity.TraceId:            f8ef93234839f4c96ac79e2a48a3ae49
Activity.SpanId:             e8293265d46543e3
Activity.DisplayName:        ConduitClient.Execute
Activity.Kind:               Client
    |
    +--- Activity.DisplayName: Filter: LeaderRoutingFilter
         Activity.Kind:        Internal
         |
         +--- (Network Call to Gateway)
              |
              +--- Activity.DisplayName: ConduitServer.Process
                   Activity.Kind:        Server
                   Activity.SpanId:      11ef2ef0f3ca7e3c</code></pre>
                                </div>

                                <h3>Enabling Telemetry</h3>
                                <p>To enable telemetry in your ConduitNet application, simply add the OpenTelemetry SDK and subscribe to the "ConduitNet" source.</p>
                                <pre><code>builder.Services.AddOpenTelemetry()
    .WithTracing(tracerProviderBuilder =>
    {
        tracerProviderBuilder
            .AddSource("ConduitNet") // &lt;-- Subscribe to ConduitNet traces
            .AddConsoleExporter();   // Or AddOtlpExporter() for Jaeger/Aspire
    });</code></pre>

							</section>

					</div>
				</div>

			<!-- Footer -->
                <conduit-footer></conduit-footer>

		</div>

		<!-- Scripts -->
			<!-- Scripts are handled by Vite modules -->

	</body>
</html>
